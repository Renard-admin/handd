<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–£–ª—É—á—à–µ–Ω–Ω–æ–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ</title>
    <style>
        /* –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —Å—Ç–∏–ª–∏ */
        body, html { margin: 0; overflow: hidden; }
        #container { position: relative; width: 100vw; height: 100vh; }
        .video-layer { transform: scaleX(-1); }
        .canvas-layer { position: absolute; pointer-events: none; }
        .controls { position: fixed; top: 10px; right: 10px; z-index: 1000; }
        button { margin: 5px; padding: 8px 15px; background: #444; color: white; border: none; cursor: pointer; }
        .info-box { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px; }
    </style>
</head>
<body>
    <div id="container">
        <video class="video-layer" id="video" autoplay playsinline></video>
        <canvas id="handCanvas" class="canvas-layer"></canvas>
        <canvas id="faceCanvas" class="canvas-layer"></canvas>
        <canvas id="objectCanvas" class="canvas-layer"></canvas>
        <div class="info-box">–ñ–µ—Å—Ç—ã: ‚úä‚úäüëâ - —Ä–∏—Å–æ–≤–∞—Ç—å | üëå - –æ—á–∏—Å—Ç–∏—Ç—å</div>
        <div class="controls">
            <button id="fullscreenBtn">‚õ∂</button>
            <button id="switchCameraBtn">üîÑ –ö–∞–º–µ—Ä–∞</button>
        </div>
    </div>

    <!-- –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>

    <script>
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
        const video = document.getElementById('video');
        const handCanvas = document.getElementById('handCanvas');
        const faceCanvas = document.getElementById('faceCanvas');
        const objectCanvas = document.getElementById('objectCanvas');
        
        let currentStream = null;
        let isDrawing = false;
        let fistCount = 0;
        let modelsLoaded = false;

        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è
        const config = {
            dangerousObjects: ['knife', 'scissors', 'gun', 'firearm'],
            foodObjects: ['apple', 'banana', 'pizza', 'sandwich', 'orange']
        };

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥–µ–ª–µ–π
        async function initializeModels() {
            await Promise.all([
                faceapi.nets.tinyFaceDetector.loadFromUri('/models'),
                faceapi.nets.ageGenderNet.loadFromUri('/models'),
                faceapi.nets.faceExpressionNet.loadFromUri('/models'),
                cocoSsd.load()
            ]);
            modelsLoaded = true;
        }

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–∞–º–µ—Ä—ã
        async function setupCamera(facingMode = 'user') {
            const constraints = {
                video: { 
                    facingMode: facingMode,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                if (currentStream) currentStream.getTracks().forEach(track => track.stop());
                currentStream = stream;
                video.srcObject = stream;
                await new Promise(resolve => video.onloadedmetadata = resolve);
                setupCanvases();
            } catch (error) {
                alert('–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —Ä–∞–∑—Ä–µ—à–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ!');
            }
        }

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ö–æ–ª—Å—Ç–æ–≤
        function setupCanvases() {
            [handCanvas, faceCanvas, objectCanvas].forEach(canvas => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
            });
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Mediapipe Hands
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.5
        });

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è —Ä—É–∫
        hands.onResults((results) => {
            const ctx = handCanvas.getContext('2d');
            ctx.clearRect(0, 0, handCanvas.width, handCanvas.height);
            
            if (results.multiHandLandmarks) {
                results.multiHandLandmarks.forEach(landmarks => {
                    // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ä–∞–º–∫–∏ —Ä—É–∫–∏
                    drawHandBoundingBox(ctx, landmarks);
                    
                    // –õ–æ–≥–∏–∫–∞ –∂–µ—Å—Ç–æ–≤
                    processGestures(landmarks);
                });
            }
        });

        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ä–∞–º–∫–∏ —Ä—É–∫–∏
        function drawHandBoundingBox(ctx, landmarks) {
            const xs = landmarks.map(l => l.x);
            const ys = landmarks.map(l => l.y);
            const x = Math.min(...xs) * handCanvas.width;
            const y = Math.min(...ys) * handCanvas.height;
            const width = (Math.max(...xs) - Math.min(...xs)) * handCanvas.width;
            const height = (Math.max(...ys) - Math.min(...ys)) * handCanvas.height;
            
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);
        }

        // –õ–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∂–µ—Å—Ç–æ–≤
        function processGestures(landmarks) {
            const isFist = checkFistGesture(landmarks);
            const isIndex = checkIndexGesture(landmarks);
            const isOk = checkOkGesture(landmarks);

            if (isFist) handleFistGesture();
            if (isIndex && fistCount >= 2) startDrawing(landmarks);
            if (isOk) clearDrawing();
        }

        // –û—Å—Ç–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∂–µ—Å—Ç–æ–≤...

        // –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤
        async function detectObjects() {
            if (!modelsLoaded) return;
            const predictions = await cocoSsd.detect(video);
            const ctx = objectCanvas.getContext('2d');
            ctx.clearRect(0, 0, objectCanvas.width, objectCanvas.height);
            
            predictions.forEach(prediction => {
                const [x, y, width, height] = prediction.bbox;
                ctx.strokeStyle = getObjectColor(prediction.class);
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, width, height);
                ctx.fillStyle = ctx.strokeStyle;
                ctx.fillText(`${prediction.class} (${Math.round(prediction.score*100)}%)`, x, y-5);
            });
        }

        // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ —Ä–∞–º–∫–∏ –æ–±—ä–µ–∫—Ç–∞
        function getObjectColor(className) {
            if (config.dangerousObjects.includes(className)) return '#ff0000';
            if (config.foodObjects.includes(className)) return '#00ff00';
            return '#ffff00';
        }

        // –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏
        async function processFrame() {
            if (!modelsLoaded || video.paused) return;
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä—É–∫
            await hands.send({image: video});
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ª–∏—Ü –∏ –æ–±—ä–µ–∫—Ç–æ–≤
            await Promise.all([detectFaces(), detectObjects()]);
            
            requestAnimationFrame(processFrame);
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        (async function main() {
            await initializeModels();
            await setupCamera();
            video.play();
            processFrame();
        })();

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–Ω–æ–ø–æ–∫
        document.getElementById('switchCameraBtn').addEventListener('click', async () => {
            const newMode = currentStream.getVideoTracks()[0].getSettings().facingMode === 'user' 
                ? 'environment' : 'user';
            await setupCamera(newMode);
        });

        document.getElementById('fullscreenBtn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });
    </script>
</body>
</html>
